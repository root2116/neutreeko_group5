・ハッシュテーブル



・エンコーディング方式
盤面の状態に関してグラフを構築する際に、盤面の状況と一対一に対応するような整数が必要になった。そこで最初に考え出されたエンコード方式は、盤面に左上から右下にかけて0から24の数字を振り、その数字を白駒、黒駒の順で並べるという方式だった（以後、ナイーブエンコーディングと呼ぶ)。例えば初期状態は、010317072123である。上位6桁が白駒の配置、下位6桁が黒駒の配置を示している。

当初、最善手の辞書を読み込む速度はできるだけ早くしたいと考えていた。しかしこのナイーブエンコーディングだとハッシュテーブルのキーにlong intを使うことになり（エンコードされた整数の最大値がunsigned intの最大値2^32-1を超えているため）、ファイルの読み込み速度が遅くなることが懸念された。そこで考え出されたのが、int型に収まるエンコーディング方式である（以後intエンコーディングと呼ぶ）。

初期のintエンコーディングは、盤面の状況を2進数で表す方式であった。LSBから6bit目までは駒の色の情報を入れ（黒が0、白が1)、7bit目からの25bitは駒の位置情報を入れた（駒があれば1、なければ0)。よって合計31bitの2進数にエンコードされる。例えば初期状態なら、駒の位置情報は、01010 00100 00000 00100 01010であり、駒の色の情報は110100であるので、合わせると01010 00100 00000 00100 01010 110100 = 679486132となる。

初めは、このintエンコーディングで盤面をエンコードした値をハッシュテーブルのキーとして使い、グラフを生成した。このエンコーディング方式だと盤面の状況しか表していない。したがって、ある盤面から黒を動かしたときの盤面に関するグラフと、ある盤面から白を動かしたときの盤面に関するグラフをあわせて、2部グラフとして操作することになる。しかし2部グラフだと最善手判定アルゴリズムのほうで、処理が複雑になるということが判明したので、急遽、手番の情報を追加でエンコードすることになった。

ハッシュテーブルの構造体に手番の情報を表すint型の変数を追加するという案もあったが、せっかく8バイトのlong intを4バイトのintにした意味がなくなるので却下された。その後、少しして機転が訪れた。intエンコーディングは、よくよく考えるとMSBが空いているではないか。それは手番の情報をいれるためだけに1bit空いていたかのようであった。そこに手番の情報を入れ（黒の手番であれば0、白の手番であれば1）、合計ぴったり32bitになった（以後uintエンコーディングと呼ぶ）。

uintエンコーディングでエンコードされた盤面は、int型に入りはするが、負の数になる場合がある。ハッシュテーブルでは素数で割った余り
によってハッシングしていたので、ハッシュ値が負の数になると困る。そこでint型ではなくunsigned intに格納することにした。

uintエンコーディングだけをエンコーディング方式として使ったかというとそうではない。このエンコーディングには欠点がある。それはあり得る全盤面を容易に走査できないということである。ゆえに全盤面を走査する際はナイーブエンコーディングをして、実際にハッシュテーブルにキーを入れる際はuintエンコーディングに変換して入れた。


・アルゴリズム



・ファイルI/O

Pythonでグラフを構築すると15分ほどかかることがわかった。C言語で構築すればもう少し早くなるだろうと思ったが、デバッグ時にいちいちグラフを構築していたら提出に間に合わないかもしれなかったので、グラフなどの中間データを保存するファイルI/Oプログラムを書いた。ゲームをプレイする際は最善手の辞書ファイルを読み込むので、ファイルI/Oプログラムはいずれにせよ作る必要があったが、早めに書いていたことでデバッグ時間が短縮された。
Pythonではテキストファイルとして保存していたが、読み込みに40秒ほどかかるので、C言語ではバイナリとしてファイルに保存した。その結果読み込み速度は2秒ほどに短縮された。
普通のint型の１次元配列や2次元配列はバイナリでファイルに保存することは容易であるが、構造体の配列であるハッシュテーブルの保存は少し厄介だった。まず本プログラムにおけるハッシュテーブルはチェイン法を採用しているので、ハッシュ値が衝突したデータに関してはチェインの先まで潜ってデータを拾う必要があった。今振り返ると、開番地法を採用していれば、構造体の配列のインデックスをただ舐めるだけでファイルに保存できたと思う。

