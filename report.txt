・ハッシュテーブル
ハッシュをCで実装するという工夫を行った。そのことにより、符号化された盤面に、ハッシュテーブルを用いてO(1)での高速なアクセスが可能になった。

ハッシュは符号化した盤面のIDを、ありえる盤面数を超える大きさの素数で割った余りとして計算している。

ここで、割る数を大きな素数としている目的は、衝突をなるべく避けることにある。

今回はチェイン法を用いており、ハッシュが衝突したときにも対応可能となっている。


・エンコーディング方式
盤面の状態に関してグラフを構築する際に、盤面の状況と一対一に対応するような整数が必要になった。そこで最初に考え出されたエンコード方式は、盤面に左上から右下にかけて0から24の数字を振り、その数字を白駒、黒駒の順で並べるという方式だった（以後、ナイーブエンコーディングと呼ぶ)。例えば初期状態は、010317072123である。上位6桁が白駒の配置、下位6桁が黒駒の配置を示している。

当初、最善手の辞書を読み込む速度はできるだけ早くしたいと考えていた。しかしこのナイーブエンコーディングだとハッシュテーブルのキーにlong intを使うことになり（エンコードされた整数の最大値がunsigned intの最大値2^32-1を超えているため）、ファイルの読み込み速度が遅くなることが懸念された。そこで考え出されたのが、int型に収まるエンコーディング方式である（以後intエンコーディングと呼ぶ）。

初期のintエンコーディングは、盤面の状況を2進数で表す方式であった。LSBから6bit目までは駒の色の情報を入れ（黒が0、白が1)、7bit目からの25bitは駒の位置情報を入れた（駒があれば1、なければ0)。よって合計31bitの2進数にエンコードされる。例えば初期状態なら、駒の位置情報は、01010 00100 00000 00100 01010であり、駒の色の情報は110100であるので、合わせると01010 00100 00000 00100 01010 110100 = 679486132となる。

初めは、このintエンコーディングで盤面をエンコードした値をハッシュテーブルのキーとして使い、グラフを生成した。しかし、同じ盤面でも手番によって勝者が異なることもあり得て、これらを同時に扱うことは困難であるため、急遽、手番の情報を追加でエンコードし、1つの盤面に手番によって2つの頂点が対応するグラフを作成することとなった。

ハッシュテーブルの構造体に手番の情報を表すint型の変数を追加するという案もあったが、せっかく8バイトのlong intを4バイトのintにした意味がなくなるので却下された。その後、少しして機転が訪れた。intエンコーディングは、よくよく考えるとMSBが空いているではないか。それは手番の情報をいれるためだけに1bit空いていたかのようであった。そこに手番の情報を入れ（黒の手番であれば0、白の手番であれば1）、合計ぴったり32bitになった（以後uintエンコーディングと呼ぶ）。

uintエンコーディングでエンコードされた盤面は、int型に入りはするが、負の数になる場合がある。ハッシュテーブルでは素数で割った余り
によってハッシングしていたので、ハッシュ値が負の数になると困る。そこでint型ではなくunsigned intに格納することにした。

uintエンコーディングだけをエンコーディング方式として使ったかというとそうではない。このエンコーディングには欠点がある。それはあり得る全盤面を容易に走査できないということである。ゆえに全盤面を走査する際はナイーブエンコーディングをして、実際にハッシュテーブルにキーを入れる際はuintエンコーディングに変換して入れた。


・アルゴリズム
group5のAI、Inverseは、各盤面が指し手側から見て勝ちの盤面（詰みがある）、負けの盤面（どの手を指しても次の相手の手番で詰みが生じる）、中立の盤面（両者が適切な手を選び続ければ決着がつかない盤面）のうちどれに分類されるかを計算し、それをもとに各盤面でどの指し手を選ぶべきかを計算する。
本節ではここで用いたアルゴリズムについて簡単に説明する。


1．各盤面の勝敗の判定

まず、各盤面（駒の配置と手番の情報）を列挙し、盤面の状態を頂点、各指し手を辺とする有向グラフを構築する。
ここで、すでにどちらかの駒が一直線に並び、決着がついている盤面からは辺を張らないこととする。
次に、各盤面について、その遷移先の盤面のうち、負けで勝敗が確定した盤面の数、勝ちで勝敗が確定したものの数をそれぞれ保存する2次元配列（next_condition_table）を用意する。
また、各盤面についてどのタイミングで勝敗が確定したかを保存する配列（max_edges_to_end_table）を用意する。
その次に、既に決着がついている盤面のidを配列（new_fixed_index_arrayとする）に保存する。
最後に、新たに勝敗が確定する盤面がなくなる（new_fixed_index_arrayに盤面が追加されなくなる）まで以下を繰りかえす。

　1．new_fixed_index_arrayの中身を初期化された別の配列（fixed_index_arrayとする）に移し、new_fixed_index_arrayを初期化する。
　2．fixed_index_arrayの中の各盤面（nowとする）について、nowに1手で遷移できる盤面のうち、まだ勝敗の確定していないもの（uncertainとする）のnext_condition_tableを更新しuncertainの勝敗を以下のルールで判定する。
　　 uncertainの勝敗が新たに確定した場合、uncertainのidをnew_fixed_index_arrayに追加し、勝ちで確定したなら現在のループ数を、負けで確定したなら現在のループ数にマイナスをつけた数をmax_edges_to_end_tableに保存する。

　勝敗判定ルール
　　1．遷移先に相手の負けの盤面が1つでもあるなら、その盤面は勝ちである。（その相手の負けの盤面に遷移する手を指せばよいため。）
　　2．遷移先が全て相手の勝ちの盤面ならば、その盤面は負けである。（どの手を指しても相手の勝ちのため。）
　　3．上記に当てはまらなければ、現段階ではその盤面の勝敗は確定しない。最後まで勝敗が確定せずに残ればその盤面は中立の盤面である。


2．指し手の計算
　各盤面について、以下のルールで最善手を計算する。
　1．その盤面が勝ち盤面なら、遷移先の相手の負け盤面のうち、max_edges_to_end_tableに入っている数が一番大きいものに遷移する。（最も早く勝てる手を選ぶ。）
　2．その盤面が負け盤面なら、遷移先の相手の勝ち盤面のうち、max_edges_to_end_tableに入っている数が一番大きいものに遷移する。（最も遅く負ける手を選ぶ。）
　3．その盤面が中立盤面なら、遷移先の中立盤面のうち1つを選ぶ。


3．アルゴリズムのポイント等
　・はじめはゲーム木を作り最善手を計算することを考えたが、このゲームは同じ盤面に帰ってきてループすることがあるため難しかった。
　　取りうる状態数が少ないことを用いて、木を有向グラフに置き換えて考えることでこのアルゴリズムを考案した。
　・勝敗判定では、新しく勝敗が確定する盤面がなくなるまで各盤面に勝敗判定ルールを適応すればよい。
　　これを愚直に行えばO(V*E)である。
　　ここで、新たに盤面の勝敗が確定するのは、遷移先の勝敗の情報が更新されるときのみであることなどを用いて、このアルゴリズムでは計算量をO(E)に落としている。
　・指し手の計算する際、自分が勝ちの盤面にいるならば、相手の負けの盤面に遷移すればどの盤面に遷移してもよいように思えるが、例えば３手で自分の勝つ盤面から４手で相手が負ける盤面に遷移していては決着がつかず、最悪引き分けとなってしまう。
　　確実に決着に近づき、このような事態を避けるために、max_edges_to_end_tableで決着までの最大手数を管理している。



・ファイルI/O

Pythonでグラフを構築すると9分ほどかかることがわかった。C言語で構築すればもう少し早くなるだろうと思ったが、デバッグ時にいちいちグラフを構築していたら提出に間に合わないかもしれなかったので、グラフなどの中間データを保存するファイルI/Oプログラムを書いた。ゲームをプレイする際は最善手の辞書ファイルを読み込むので、ファイルI/Oプログラムはいずれにせよ作る必要があったが、早めに書いていたことでデバッグ時間が短縮された。
Pythonではテキストファイルとして保存していたが、読み込みに25秒ほどかかるので、C言語ではバイナリとしてファイルに保存した。その結果読み込み速度は3秒ほどに短縮された。
普通のint型の１次元配列や2次元配列はバイナリでファイルに保存することは容易であるが、構造体の配列であるハッシュテーブルの保存は少し厄介だった。まず本プログラムにおけるハッシュテーブルはチェイン法を採用しているので、ハッシュ値が衝突したデータに関してはチェインの先まで潜ってデータを拾う必要があった。今振り返ると、開番地法を採用していれば、構造体の配列のインデックスをただ舐めるだけでファイルに保存できたと思う。

